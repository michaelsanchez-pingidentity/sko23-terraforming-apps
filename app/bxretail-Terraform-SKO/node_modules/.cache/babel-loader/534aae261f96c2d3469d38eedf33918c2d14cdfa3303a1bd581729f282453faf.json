{"ast":null,"code":"/**\n * Class representing functions to integrate with the browser\n * session and local storage API to maintain user state during\n * an authenticated app session. Also includes a method for \n * access rules.\n * \n * @author Michael Sanchez, Eric Anderson\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage}\n*/\n\nclass Session {\n  /** \n  Protect Page:\n  Ensures a user doesn't access pages when unauthenticated or \n  when not the right user type. We are not using Ping Access for a SaaS-first demo.\n  THIS IS JUST FOR DEMO PURPOSES. NOT REAL WORLD IMPLEMENTATION.\n   @param {boolean} loggedOut Whether the user is logged in or not.\n  @param {string} path Where the user is trying to go.\n  @param {string} userType AnyTVPartner, AnyMarketing, or customer. \n  @param {object} props React properties.\n  */\n  protectPage(loggedOut, path, userType, props) {\n    const customerAllowedPaths = ['/app/admin/', '/app/dashboard/settings', '/app/dashboard/settings/profile', '/app/dashboard/settings/communication-preferences', '/app/dashboard/settings/privacy-security'];\n    const unauthenticatedPaths = ['/', '/app/', '/app', '/app/shop', '/app/shop/checkout'];\n    console.info('Utils.Session', 'Checking access rules for user type ' + userType + ' at ' + path);\n    this.removeAuthenticatedUserItem('triggerLogin', 'session');\n    //They have to be logged in to be anywhere other than home or /shop.\n    if (loggedOut && !unauthenticatedPaths.includes(path)) {\n      console.info('Access rule', 'Attempting to access protected page as unauthenticated user. Redirecting to home.');\n      if (path === '/app/dashboard/settings') {\n        this.setAuthenticatedUserItem('triggerLogin', true, 'session');\n      }\n      props.history.push(unauthenticatedPaths[0]);\n    } else {\n      switch (userType) {\n        case 'Customer':\n          if (!customerAllowedPaths.includes(path) && !unauthenticatedPaths.includes(path)) {\n            console.info('Access Rule', 'Attempt to access disallowed resource for user type ' + userType + '. Redirecting to default.');\n            props.history.push(unauthenticatedPaths[0]);\n          }\n          break;\n        default:\n          console.warn('Unknown bxRetailUserType:', 'Not authenticated yet.');\n      }\n    }\n  }\n\n  /** \n   * Get Authenticated User Item\n   * Gets an item from the current origin's session (or local) storage. For local storage item's expiry rules will be enforced if present.\n   * \n   * @param {string} key The item name in storage.\n   * @param {string} type session or local.\n   * @return {string} DOM String.\n  */\n  getAuthenticatedUserItem(key, type) {\n    console.info('Utils.Session', 'Getting ' + key + ' from ' + type + ' browser storage.');\n    if (type === 'session') {\n      return sessionStorage.getItem(key);\n    } else {\n      const value = localStorage.getItem(key);\n      const propertyRegex = /((\"|')expiryRule(\"|')):|expiryRule:/; // Looking for \"expiryRule\":, 'expiryRule': or expiryRule:\n\n      if (value && propertyRegex.test(value)) {\n        const item = JSON.parse(value);\n        if (!(item !== null && item !== void 0 && item.expiryRule)) {\n          return null;\n        }\n        switch (item.expiryRule) {\n          case 'oneTimeUse':\n            localStorage.removeItem(key);\n            return item.value;\n          case 'expiryDate':\n            if (item.expireDate && item.expireDate > new Date()) {\n              return item.value;\n            } else {\n              console.info('LocalStorage.js', `Item '${key}' found in local storage but is expired, removing.`);\n              localStorage.removeItem(key);\n              return null;\n            }\n          default:\n            console.warn(`Invalid expiry rule encountered ${item.expireRule}`);\n            return item.value;\n        }\n      }\n      return value;\n    }\n  }\n\n  /** \n   * Set Authenticated User Item\n   * Sets an item in the current origin's sessions storage.\n   * \n   * @param {string} key The item name to set in storage.\n   * @param {string} value The string value of the key.\n   * @param {string} type session or local.\n   * @return {void} Undefined.\\\n   * @throws {storageFullException} Particularly, in Mobile Safari \n   *                           (since iOS 5) it always throws when \n   *                           the user enters private mode. \n   *                           (Safari sets the quota to 0 bytes in \n   *                           private mode, unlike other browsers, \n   *                           which allow storage in private mode \n   *                           using separate data containers.)\n  */\n  setAuthenticatedUserItem(key, value, type) {\n    console.info('Utils.Session', 'Saving ' + key + ' into ' + type + ' browser storage.');\n    if (type === 'session') {\n      sessionStorage.setItem(key, value);\n    } else {\n      localStorage.setItem(key, value);\n    }\n  }\n\n  /**\n   * Sets a value in current origin's local storage with an expiry rule that is enforced on retrieval\n   *\n   * @param {string} key The item name to save in storage\n   * @param {any} value The item value of the key\n   * @param {string} expiryRule Expiry rule type, current options are 'endOfDay' and 'oneTimeUse'\n   * @return {void} undefined\n   */\n  setLocalStorageItemWithExpiry(key, value, expiryRule) {\n    let objToSave = {\n      expiryRule: expiryRule,\n      value: value\n    };\n    const validExpiryOptions = ['endOfDay', 'oneTimeUse'];\n    if (validExpiryOptions.indexOf(objToSave.expiryRule) === -1) {\n      console.warn('Session.js', `Invalid expiryRule encountered for '${key}', default of 'none' will be used.`);\n      objToSave.expiryRule = 'none';\n    }\n    if (expiryRule === 'endOfDay') {\n      objToSave.expireDate = new Date().setHours(23, 59, 59, 999);\n      objToSave.expiryRule = 'expiryDate';\n    }\n    console.info('LocalStorage.js', `Saving ${key} to local storage.`, objToSave);\n    localStorage.setItem(key, JSON.stringify(objToSave));\n    return true;\n  }\n\n  /** \n   * Remove Authenticated User Item\n   * Removes an item from the current origin's session storage.\n   * \n   * @param {string} key The item name in storage to remove.\n   * @param {string} type session or local.\n   * @return {void} Undefined.\n  */\n  removeAuthenticatedUserItem(key, type) {\n    console.info('Utils.Session', 'Removing ' + key + ' from ' + type + ' browser storage.');\n    if (type === 'session') {\n      sessionStorage.removeItem(key);\n    } else {\n      localStorage.removeItem(key);\n    }\n  }\n\n  /** \n   * Clear a user's local app session\n   * Clears out everything in the current origin's session storage.\n   * \n   * @param {string} type Type of storage: session, local, all.\n   * @return {void} Undefined.\n   */\n  clearUserAppSession(type) {\n    console.info('Utils.Session', 'Removing ' + type + ' browser storage.');\n    switch (type) {\n      case 'session':\n        sessionStorage.clear();\n        break;\n      case 'local':\n        localStorage.clear();\n        break;\n      case 'all':\n        sessionStorage.clear();\n        localStorage.clear();\n        break;\n      default:\n        console.error('Storage Error:', \"The 'type' param to clearUserAppSession was not recognized or excluded. No storage has been cleared.\");\n    }\n  }\n\n  /** \n   * Get Cookie\n   * We set a cookie when users check \"Remember Me\" when logging in.\n   * We need to check for this cookie in a couple different places to set state.\n   * \n   * @deprecated Using browser storage going forward for demo apps.\n   * @param {string} cookieName The name of the cookie we want the value of.\n   * @return {string} Cookie value, or an empty string if not found.\n  */\n  getCookie(cookieName) {\n    console.info('Utils.Session', 'Getting a cookie value from the browser.');\n    const name = cookieName + '=';\n    const decodedCookie = decodeURIComponent(document.cookie);\n    const ca = decodedCookie.split(';');\n    for (let i = 0; i < ca.length; i++) {\n      let c = ca[i];\n      while (c.charAt(0) === ' ') {\n        c = c.substring(1);\n      }\n      if (c.indexOf(name) === 0) {\n        return c.substring(name.length, c.length);\n      }\n    }\n    return '';\n  }\n\n  /**\n   * Delete Cookie\n   * We set a cookie when users unchecks \"Remember Me\" when logging in.\n   * \\\n   * @deprecated Using browser storage going forward for demo apps.\n   * @param {string} name The name of the cookie we want to delete.\n   * @param {string} path The app path to which the cookie is assigned.\n   * @param {string} domain The domain name to which the cookie is assigned.\\\n   * @return {string} Cookie value, or an empty string if not found.\n  */\n  deleteCookie(_ref) {\n    let {\n      name,\n      path,\n      domain\n    } = _ref;\n    console.info('Utils.Session', 'Deleting a cookie value from the browser.');\n    if (this.getCookie(name)) {\n      document.cookie = name + '=' + (path ? ';path=' + path : '') + (domain ? ';domain=' + domain : '') + ';expires=Thu, 01 Jan 1970 00:00:01 GMT';\n    }\n  }\n}\nexport default Session;","map":{"version":3,"names":["Session","protectPage","loggedOut","path","userType","props","customerAllowedPaths","unauthenticatedPaths","console","info","removeAuthenticatedUserItem","includes","setAuthenticatedUserItem","history","push","warn","getAuthenticatedUserItem","key","type","sessionStorage","getItem","value","localStorage","propertyRegex","test","item","JSON","parse","expiryRule","removeItem","expireDate","Date","expireRule","setItem","setLocalStorageItemWithExpiry","objToSave","validExpiryOptions","indexOf","setHours","stringify","clearUserAppSession","clear","error","getCookie","cookieName","name","decodedCookie","decodeURIComponent","document","cookie","ca","split","i","length","c","charAt","substring","deleteCookie","domain"],"sources":["/Users/michaelsanchez/projects/TechnicalEnablement/vscode-workspaces/BXRetail/BXRetail-Apps/bxretail/src/components/Utils/Session.js"],"sourcesContent":["/**\n * Class representing functions to integrate with the browser\n * session and local storage API to maintain user state during\n * an authenticated app session. Also includes a method for \n * access rules.\n * \n * @author Michael Sanchez, Eric Anderson\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage}\n*/\n\nclass Session {\n    /** \n    Protect Page:\n    Ensures a user doesn't access pages when unauthenticated or \n    when not the right user type. We are not using Ping Access for a SaaS-first demo.\n    THIS IS JUST FOR DEMO PURPOSES. NOT REAL WORLD IMPLEMENTATION.\n\n    @param {boolean} loggedOut Whether the user is logged in or not.\n    @param {string} path Where the user is trying to go.\n    @param {string} userType AnyTVPartner, AnyMarketing, or customer. \n    @param {object} props React properties.\n    */\n    protectPage(loggedOut, path, userType, props) {\n        const customerAllowedPaths = [\n            '/app/admin/',\n            '/app/dashboard/settings',\n            '/app/dashboard/settings/profile',\n            '/app/dashboard/settings/communication-preferences',\n            '/app/dashboard/settings/privacy-security',\n        ];\n        const unauthenticatedPaths = ['/', '/app/', '/app', '/app/shop', '/app/shop/checkout'];\n        console.info('Utils.Session', 'Checking access rules for user type ' + userType + ' at ' + path);\n\n        this.removeAuthenticatedUserItem('triggerLogin', 'session');\n        //They have to be logged in to be anywhere other than home or /shop.\n        if (loggedOut && !unauthenticatedPaths.includes(path)) {\n            console.info(\n                'Access rule',\n                'Attempting to access protected page as unauthenticated user. Redirecting to home.'\n            );\n            if (path === '/app/dashboard/settings') {\n                this.setAuthenticatedUserItem('triggerLogin', true, 'session');\n            }\n            props.history.push(unauthenticatedPaths[0]);\n        } else {\n            switch (userType) {\n                case 'Customer':\n                    if (!customerAllowedPaths.includes(path) && !unauthenticatedPaths.includes(path)) {\n                        console.info(\n                            'Access Rule',\n                            'Attempt to access disallowed resource for user type ' +\n                                userType +\n                                '. Redirecting to default.'\n                        );\n                        props.history.push(unauthenticatedPaths[0]);\n                    }\n                    break;\n                default:\n                    console.warn('Unknown bxRetailUserType:', 'Not authenticated yet.');\n            }\n        }\n    }\n\n    /** \n     * Get Authenticated User Item\n     * Gets an item from the current origin's session (or local) storage. For local storage item's expiry rules will be enforced if present.\n     * \n     * @param {string} key The item name in storage.\n     * @param {string} type session or local.\n     * @return {string} DOM String.\n    */\n    getAuthenticatedUserItem(key, type) {\n        console.info('Utils.Session', 'Getting ' + key + ' from ' + type + ' browser storage.');\n\n        if (type === 'session') {\n            return sessionStorage.getItem(key);\n        } else {\n            const value = localStorage.getItem(key);\n            const propertyRegex = /((\"|')expiryRule(\"|')):|expiryRule:/; // Looking for \"expiryRule\":, 'expiryRule': or expiryRule:\n\n            if (value && propertyRegex.test(value)) {\n                const item = JSON.parse(value);\n\n                if (!item?.expiryRule) {\n                    return null;\n                }\n\n                switch (item.expiryRule) {\n                    case 'oneTimeUse':\n                        localStorage.removeItem(key);\n                        return item.value;\n                    case 'expiryDate':\n                        if (item.expireDate && item.expireDate > new Date()) {\n                            return item.value;\n                        } else {\n                            console.info(\n                                'LocalStorage.js',\n                                `Item '${key}' found in local storage but is expired, removing.`\n                            );\n                            localStorage.removeItem(key);\n                            return null;\n                        }\n                    default:\n                        console.warn(`Invalid expiry rule encountered ${item.expireRule}`);\n                        return item.value;\n                }\n            }\n\n            return value;\n        }\n    }\n\n    /** \n     * Set Authenticated User Item\n     * Sets an item in the current origin's sessions storage.\n     * \n     * @param {string} key The item name to set in storage.\n     * @param {string} value The string value of the key.\n     * @param {string} type session or local.\n     * @return {void} Undefined.\\\n     * @throws {storageFullException} Particularly, in Mobile Safari \n     *                           (since iOS 5) it always throws when \n     *                           the user enters private mode. \n     *                           (Safari sets the quota to 0 bytes in \n     *                           private mode, unlike other browsers, \n     *                           which allow storage in private mode \n     *                           using separate data containers.)\n    */\n    setAuthenticatedUserItem(key, value, type) {\n        console.info('Utils.Session', 'Saving ' + key + ' into ' + type + ' browser storage.');\n\n        if (type === 'session') {\n            sessionStorage.setItem(key, value);\n        } else {\n            localStorage.setItem(key, value);\n        }\n    }\n\n    /**\n     * Sets a value in current origin's local storage with an expiry rule that is enforced on retrieval\n     *\n     * @param {string} key The item name to save in storage\n     * @param {any} value The item value of the key\n     * @param {string} expiryRule Expiry rule type, current options are 'endOfDay' and 'oneTimeUse'\n     * @return {void} undefined\n     */\n    setLocalStorageItemWithExpiry(key, value, expiryRule) {\n        let objToSave = {\n            expiryRule: expiryRule,\n            value: value,\n        };\n\n        const validExpiryOptions = ['endOfDay', 'oneTimeUse'];\n        if (validExpiryOptions.indexOf(objToSave.expiryRule) === -1) {\n            console.warn('Session.js', `Invalid expiryRule encountered for '${key}', default of 'none' will be used.`);\n            objToSave.expiryRule = 'none';\n        }\n\n        if (expiryRule === 'endOfDay') {\n            objToSave.expireDate = new Date().setHours(23, 59, 59, 999);\n            objToSave.expiryRule = 'expiryDate';\n        }\n\n        console.info('LocalStorage.js', `Saving ${key} to local storage.`, objToSave);\n\n        localStorage.setItem(key, JSON.stringify(objToSave));\n\n        return true;\n    }\n\n    /** \n     * Remove Authenticated User Item\n     * Removes an item from the current origin's session storage.\n     * \n     * @param {string} key The item name in storage to remove.\n     * @param {string} type session or local.\n     * @return {void} Undefined.\n    */\n    removeAuthenticatedUserItem(key, type) {\n        console.info('Utils.Session', 'Removing ' + key + ' from ' + type + ' browser storage.');\n\n        if (type === 'session') {\n            sessionStorage.removeItem(key);\n        } else {\n            localStorage.removeItem(key);\n        }\n    }\n\n    /** \n     * Clear a user's local app session\n     * Clears out everything in the current origin's session storage.\n     * \n     * @param {string} type Type of storage: session, local, all.\n     * @return {void} Undefined.\n     */\n    clearUserAppSession(type) {\n        console.info('Utils.Session', 'Removing ' + type + ' browser storage.');\n\n        switch (type) {\n            case 'session':\n                sessionStorage.clear();\n                break;\n            case 'local':\n                localStorage.clear();\n                break;\n            case 'all':\n                sessionStorage.clear();\n                localStorage.clear();\n                break;\n            default:\n                console.error(\n                    'Storage Error:',\n                    \"The 'type' param to clearUserAppSession was not recognized or excluded. No storage has been cleared.\"\n                );\n        }\n    }\n\n    /** \n     * Get Cookie\n     * We set a cookie when users check \"Remember Me\" when logging in.\n     * We need to check for this cookie in a couple different places to set state.\n     * \n     * @deprecated Using browser storage going forward for demo apps.\n     * @param {string} cookieName The name of the cookie we want the value of.\n     * @return {string} Cookie value, or an empty string if not found.\n    */\n    getCookie(cookieName) {\n        console.info('Utils.Session', 'Getting a cookie value from the browser.');\n\n        const name = cookieName + '=';\n        const decodedCookie = decodeURIComponent(document.cookie);\n        const ca = decodedCookie.split(';');\n        for (let i = 0; i < ca.length; i++) {\n            let c = ca[i];\n            while (c.charAt(0) === ' ') {\n                c = c.substring(1);\n            }\n            if (c.indexOf(name) === 0) {\n                return c.substring(name.length, c.length);\n            }\n        }\n        return '';\n    }\n\n    /**\n     * Delete Cookie\n     * We set a cookie when users unchecks \"Remember Me\" when logging in.\n     * \\\n     * @deprecated Using browser storage going forward for demo apps.\n     * @param {string} name The name of the cookie we want to delete.\n     * @param {string} path The app path to which the cookie is assigned.\n     * @param {string} domain The domain name to which the cookie is assigned.\\\n     * @return {string} Cookie value, or an empty string if not found.\n    */\n    deleteCookie({ name, path, domain }) {\n        console.info('Utils.Session', 'Deleting a cookie value from the browser.');\n\n        if (this.getCookie(name)) {\n            document.cookie =\n                name +\n                '=' +\n                (path ? ';path=' + path : '') +\n                (domain ? ';domain=' + domain : '') +\n                ';expires=Thu, 01 Jan 1970 00:00:01 GMT';\n        }\n    }\n}\n\nexport default Session;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}